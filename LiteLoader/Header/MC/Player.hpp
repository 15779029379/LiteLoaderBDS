// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#define AUTO_GENERATED
#include "../Global.h"
#include "Actor.hpp"
#include "Mob.hpp"

#define BEFORE_EXTRA
// Add include headers & pre-declares
    class ServerPlayer;
    class Player;
    class NetworkIdentifier;
    class UserEntityIdentifierComponent;
    class Certificate;
    class Container;
    class CompoundTag;
    #include "ScorePacketInfo.hpp"
    #include "DataItem.hpp"
#undef BEFORE_EXTRA

class Player : public Mob {

#define AFTER_EXTRA
// Add new members to class
public:
    enum PositionMode : char{
        NORMAL,
        RESPAWN,
        TELEPORT,
        HEAD_ROTATION,
    };

    LIAPI std::string getName();
    LIAPI std::string getRealName();
    LIAPI std::string getUuid();
    LIAPI unsigned char getClientSubId();
    LIAPI string getDeviceTypeName();
    LIAPI int getAvgPing();
    LIAPI int getLastPing();
    LIAPI std::string getIP();
    LIAPI string getLanguageCode();
    LIAPI string getServerAddress();
    LIAPI NetworkIdentifier* getNetworkIdentifier();
    LIAPI Certificate* getCertificate();
    LIAPI Container* getEnderChestContainer();
    LIAPI std::pair<BlockPos, int> getRespawnPosition();
    LIAPI float getAvgPacketLoss();
    LIAPI string getClientId();
    LIAPI int getDeviceType();
    LIAPI bool isOP();

    
    LIAPI bool sendText(string text, TextType type = TextType::RAW);
    template <typename... Args>
    bool sendFormattedText(string text, const Args&... args)
    {
        if constexpr (0 == sizeof...(args))
        {
            // Avoid fmt if only one argument
            return sendText(text);
        }
        else
            return sendText(fmt::format(text, args...));
    }

    LIAPI bool kick(const string& msg);
    LIAPI bool crashClient();
    LIAPI bool talkAs(const string& msg);
    LIAPI bool giveItem(ItemStack* item); 
    LIAPI int clearItem(string typeName);
    LIAPI bool runcmd(const string& cmd);
    LIAPI bool transferServer(const string& address, unsigned short port);
    LIAPI bool setSidebar(const std::string& title, const std::vector<std::pair<std::string, int>>& data, ObjectiveSortOrder sortOrder);
    LIAPI bool removeSidebar();
    LIAPI std::unique_ptr<CompoundTag> getNbt();
    LIAPI bool setNbt(CompoundTag* nbt);

    LIAPI int getScore(const string& key);
    LIAPI bool setScore(const string& key, int value);
    LIAPI bool addScore(const string& key, int value);
    LIAPI bool reduceScore(const string& key, int value);
    LIAPI bool deleteScore(const string& key);

    //Packet
    LIAPI bool sendTextPacket(string text, TextType Type = TextType::RAW) const;
    LIAPI bool sendTitlePacket(string text, TitleType Type, int FadeInDuration, int RemainDuration, int FadeOutDuration) const;
    LIAPI bool sendNotePacket(unsigned int tone);
    LIAPI bool sendSpawnParticleEffectPacket(Vec3 spawnPos, int dimid, string ParticleName, int64_t EntityUniqueID = -1) const;
    /*bad*/ LIAPI bool sendPlaySoundPacket(string SoundName, Vec3 Position, float Volume, float Pitch) const;
    LIAPI bool sendAddItemEntityPacket(unsigned long long runtimeID, class Item const& item, int stackSize, short aux, Vec3 pos, vector<std::unique_ptr<DataItem>> dataItems = {}) const;
    LIAPI bool sendAddEntityPacket(unsigned long long runtimeID, string entityType, Vec3 pos, Vec2 rotation, float headYaw, vector<std::unique_ptr<DataItem>> dataItems = {});
    LIAPI bool sendUpdateBlockPacket(int x, int y, int z, unsigned int runtimeId, UpdateBlockFlags flag = UpdateBlockFlags::BlockUpdateAll, UpdateBlockLayer layer = UpdateBlockLayer::UpdateBlockDefault);
    LIAPI bool sendUpdateBlockPacket(int x, int y, int z, const Block& block, UpdateBlockFlags flag = UpdateBlockFlags::BlockUpdateAll, UpdateBlockLayer layer = UpdateBlockLayer::UpdateBlockDefault);
    LIAPI bool sendTransferPacket(const string& address, short port) const;
    LIAPI bool sendSetDisplayObjectivePacket(const string& title, const string& name, char sortOrder) const;
    LIAPI bool sendSetScorePacket(char type, const vector<ScorePacketInfo>& data);
    LIAPI bool sendBossEventPacket(BossEvent type, string name, float percent, BossEventColour colour, int overlay = 0);
    LIAPI bool sendCommandRequestPacket(const string& cmd);
    LIAPI bool sendTextTalkPacket(const string& msg);

    LIAPI bool sendRawFormPacket(unsigned formId, const string& data) const;
    LIAPI bool sendSimpleFormPacket(const string& title, const string& content, const vector<string>& buttons, const std::vector<std::string>& images, std::function<void(int)> callback) const;
    LIAPI bool sendModalFormPacket(const string& title, const string& content, const string& button1, const string& button2, std::function<void(bool)> callback);
    LIAPI bool sendCustomFormPacket(const std::string& data, std::function<void(string)> callback);

    LIAPI static bool isValid(Player* player);

    //For compatibility
    inline string getDeviceName() { return getDeviceTypeName(); }

#undef AFTER_EXTRA

#ifndef DISABLE_CONSTRUCTOR_PREVENTION_PLAYER
public:
    class Player& operator=(class Player const&) = delete;
    Player(class Player const&) = delete;
    Player() = delete;
#endif

public:
    /*0*/ virtual void reloadHardcoded(enum Actor::InitializationMethod, class VariantParameterList const&);
    /*1*/ virtual void initializeComponents(enum Actor::InitializationMethod, class VariantParameterList const&);
    /*2*/ virtual void _serverInitItemStackIds();
    /*3*/ virtual ~Player();
    /*4*/ virtual void remove();
    /*5*/ virtual void __unk_vfn_0();
    /*6*/ virtual void __unk_vfn_1();
    /*7*/ virtual class Vec3 getAttachPos(enum ActorLocation, float) const;
    /*8*/ virtual void move(class Vec3 const&);
    /*9*/ virtual void move(struct IActorMovementProxy&, class Vec3 const&) const;
    /*10*/ virtual class Vec3 getInterpolatedRidingOffset(float) const;
    /*11*/ virtual void __unk_vfn_2();
    /*12*/ virtual void teleportTo(class Vec3 const&, bool, int, int);
    /*13*/ virtual void lerpMotion(class Vec3 const&);
    /*14*/ virtual std::unique_ptr<class AddActorBasePacket> tryCreateAddActorPacket();
    /*15*/ virtual void normalTick();
    /*16*/ virtual void vehicleTick();
    /*17*/ virtual float getRidingHeight();
    /*18*/ virtual void __unk_vfn_3();
    /*19*/ virtual std::string getFormattedNameTag() const;
    /*20*/ virtual void __unk_vfn_4();
    /*21*/ virtual float getCameraOffset() const;
    /*22*/ virtual void __unk_vfn_5();
    /*23*/ virtual void __unk_vfn_6();
    /*24*/ virtual void playerTouch(class Player&);
    /*25*/ virtual bool isImmobile() const;
    /*26*/ virtual void __unk_vfn_7();
    /*27*/ virtual bool isSleeping() const;
    /*28*/ virtual void setSleeping(bool);
    /*29*/ virtual void __unk_vfn_8();
    /*30*/ virtual bool isBlocking() const;
    /*31*/ virtual bool isDamageBlocked(class ActorDamageSource const&) const;
    /*32*/ virtual void __unk_vfn_9();
    /*33*/ virtual void __unk_vfn_10();
    /*34*/ virtual void __unk_vfn_11();
    /*35*/ virtual void __unk_vfn_12();
    /*36*/ virtual class Actor* findAttackTarget();
    /*37*/ virtual void __unk_vfn_13();
    /*38*/ virtual bool attack(class Actor&, enum ActorDamageCause const&);
    /*39*/ virtual void adjustDamageAmount(int&) const;
    /*40*/ virtual void onTame();
    /*41*/ virtual void onFailedTame();
    /*42*/ virtual bool isJumping() const;
    /*43*/ virtual void vehicleLanded(class Vec3 const&, class Vec3 const&);
    /*44*/ virtual bool isInvulnerableTo(class ActorDamageSource const&) const;
    /*45*/ virtual void actuallyHurt(int, class ActorDamageSource const&, bool);
    /*46*/ virtual void onBounceStarted(class BlockPos const&, class Block const&);
    /*47*/ virtual void feed(int);
    /*48*/ virtual void handleEntityEvent(enum ActorEvent, int);
    /*49*/ virtual float getPickRadius();
    /*50*/ virtual class HashedString const& getActorRendererId() const;
    /*51*/ virtual void awardKillScore(class Actor&, int);
    /*52*/ virtual void setArmor(enum ArmorSlot, class ItemStack const&);
    /*53*/ virtual class ItemStack const& getCarriedItem() const;
    /*54*/ virtual void setCarriedItem(class ItemStack const&);
    /*55*/ virtual void setOffhandSlot(class ItemStack const&);
    /*56*/ virtual class ItemStack const& getEquippedTotem() const;
    /*57*/ virtual bool consumeTotem();
    /*58*/ virtual enum ActorType getEntityTypeId() const;
    /*59*/ virtual class HashedString const& queryEntityRenderer() const;
    /*60*/ virtual struct ActorUniqueID getSourceUniqueID() const;
    /*61*/ virtual bool canFreeze() const;
    /*62*/ virtual int getPortalCooldown() const;
    /*63*/ virtual int getPortalWaitTime() const;
    /*64*/ virtual void __unk_vfn_14();
    /*65*/ virtual void __unk_vfn_15();
    /*66*/ virtual struct ActorUniqueID getControllingPlayer() const;
    /*67*/ virtual void onSynchedDataUpdate(int);
    /*68*/ virtual bool canAddPassenger(class Actor&) const;
    /*69*/ virtual void __unk_vfn_16();
    /*70*/ virtual void __unk_vfn_17();
    /*71*/ virtual void __unk_vfn_18();
    /*72*/ virtual void sendMotionPacketIfNeeded();
    /*73*/ virtual void __unk_vfn_19();
    /*74*/ virtual void startSwimming();
    /*75*/ virtual void stopSwimming();
    /*76*/ virtual enum CommandPermissionLevel getCommandPermissionLevel() const;
    /*77*/ virtual class AnimationComponent& getAnimationComponent();
    /*78*/ virtual void useItem(class ItemStackBase&, enum ItemUseMethod, bool);
    /*79*/ virtual void __unk_vfn_20();
    /*80*/ virtual void __unk_vfn_21();
    /*81*/ virtual float getMapDecorationRotation() const;
    /*82*/ virtual bool isWorldBuilder() const;
    /*83*/ virtual void __unk_vfn_22();
    /*84*/ virtual bool isAdventure() const;
    /*85*/ virtual bool add(class ItemStack&);
    /*86*/ virtual bool drop(class ItemStack const&, bool);
    /*87*/ virtual void __unk_vfn_23();
    /*88*/ virtual void setAuxValue(int);
    /*89*/ virtual void setSize(float, float);
    /*90*/ virtual void startSpinAttack();
    /*91*/ virtual void stopSpinAttack();
    /*92*/ virtual void __unk_vfn_24();
    /*93*/ virtual void __unk_vfn_25();
    /*94*/ virtual void die(class ActorDamageSource const&);
    /*95*/ virtual bool shouldDropDeathLoot() const;
    /*96*/ virtual void __unk_vfn_26();
    /*97*/ virtual bool _hurt(class ActorDamageSource const&, int, bool, bool);
    /*98*/ virtual void readAdditionalSaveData(class CompoundTag const&, class DataLoadHelper&);
    /*99*/ virtual void addAdditionalSaveData(class CompoundTag&);
    /*100*/ virtual void __unk_vfn_27();
    /*101*/ virtual void _onSizeUpdated();
    /*102*/ virtual void __unk_vfn_28();
    /*103*/ virtual void spawnAnim();
    /*104*/ virtual float getSpeed() const;
    /*105*/ virtual void setSpeed(float);
    /*106*/ virtual void travel(float, float, float);
    /*107*/ virtual void travel(struct IMobMovementProxy&, float, float, float) const;
    /*108*/ virtual void aiStep();
    /*109*/ virtual void aiStep(struct IMobMovementProxy&) const;
    /*110*/ virtual int getItemUseDuration() const;
    /*111*/ virtual float getItemUseStartupProgress() const;
    /*112*/ virtual float getItemUseIntervalProgress() const;
    /*113*/ virtual void __unk_vfn_29();
    /*114*/ virtual void __unk_vfn_30();
    /*115*/ virtual void __unk_vfn_31();
    /*116*/ virtual void sendArmorDamage(class std::bitset<4> const&);
    /*117*/ virtual std::vector<class ItemStack const* > getAllHand() const;
    /*118*/ virtual std::vector<class ItemStack const* > getAllEquipment() const;
    /*119*/ virtual void dropEquipmentOnDeath(class ActorDamageSource const&, int);
    /*120*/ virtual void dropEquipmentOnDeath();
    /*121*/ virtual void clearVanishEnchantedItemsOnDeath();
    /*122*/ virtual void sendInventory(bool);
    /*123*/ virtual void onBorn(class Actor&, class Actor&);
    /*124*/ virtual int getAttackTime();
    /*125*/ virtual float _getWalkTargetValue(class BlockPos const&);
    /*126*/ virtual void __unk_vfn_32();
    /*127*/ virtual void __unk_vfn_33();
    /*128*/ virtual std::unique_ptr<class BodyControl> initBodyControl();
    /*129*/ virtual void jumpFromGround();
    /*130*/ virtual void jumpFromGround(struct IMobMovementProxy&) const;
    /*131*/ virtual void updateAi();
    /*132*/ virtual void _serverAiMobStep();
    /*133*/ virtual void updateGliding();
    /*134*/ virtual void __unk_vfn_34();
    /*135*/ virtual void prepareRegion(class ChunkSource&);
    /*136*/ virtual void destroyRegion();
    /*137*/ virtual void suspendRegion();
    /*138*/ virtual void resendAllChunks();
    /*139*/ virtual void _fireWillChangeDimension();
    /*140*/ virtual void _fireDimensionChanged();
    /*141*/ virtual void changeDimensionWithCredits(class AutomaticID<class Dimension, int>);
    /*142*/ virtual void tickWorld(struct Tick const&);
    /*143*/ virtual void __unk_vfn_35() = 0;
    /*144*/ virtual std::vector<class ChunkPos> const& getTickingOffsets() const;
    /*145*/ virtual void moveView();
    /*146*/ virtual void setName(std::string const&);
    /*147*/ virtual void checkMovementStats(class Vec3 const&);
    /*148*/ virtual void __unk_vfn_36();
    /*149*/ virtual void __unk_vfn_37();
    /*150*/ virtual void respawn();
    /*151*/ virtual void __unk_vfn_38();
    /*152*/ virtual void resetPos(bool);
    /*153*/ virtual void __unk_vfn_39();
    /*154*/ virtual bool hasResource(int);
    /*155*/ virtual void completeUsingItem();
    /*156*/ virtual void setPermissions(enum CommandPermissionLevel);
    /*157*/ virtual void startDestroying();
    /*158*/ virtual void stopDestroying();
    /*159*/ virtual void __unk_vfn_40();
    /*160*/ virtual void __unk_vfn_41();
    /*161*/ virtual void openTrading(struct ActorUniqueID const&, bool);
    /*162*/ virtual bool canOpenContainerScreen();
    /*163*/ virtual void __unk_vfn_42();
    /*164*/ virtual void __unk_vfn_43();
    /*165*/ virtual void openInventory();
    /*166*/ virtual void __unk_vfn_44();
    /*167*/ virtual void __unk_vfn_45();
    /*168*/ virtual void displayTextObjectMessage(class TextObjectRoot const&, std::string const&, std::string const&);
    /*169*/ virtual void displayTextObjectWhisperMessage(class ResolvedTextObject const&, std::string const&, std::string const&);
    /*170*/ virtual void displayWhisperMessage(std::string const&, std::string const&, std::string const&, std::string const&);
    /*171*/ virtual enum BedSleepingResult startSleepInBed(class BlockPos const&);
    /*172*/ virtual void stopSleepInBed(bool, bool);
    /*173*/ virtual bool canStartSleepInBed();
    /*174*/ virtual int getSleepTimer() const;
    /*175*/ virtual int getPreviousTickSleepTimer() const;
    /*176*/ virtual void __unk_vfn_46();
    /*177*/ virtual void __unk_vfn_47();
    /*178*/ virtual void __unk_vfn_48();
    ///*179*/ virtual void __unk_vfn_49();
    /*180*/ virtual void __unk_vfn_50();
    /*181*/ virtual void __unk_vfn_51();
    /*182*/ virtual void registerTrackedBoss(struct ActorUniqueID);
    /*183*/ virtual void unRegisterTrackedBoss(struct ActorUniqueID);
    /*184*/ virtual void setPlayerGameType(enum GameType);
    /*185*/ virtual void initHUDContainerManager();
    /*186*/ virtual void _crit(class Actor&);
    /*187*/ virtual class IMinecraftEventing* getEventing() const;
    /*188*/ virtual void __unk_vfn_52();
    /*189*/ virtual void sendEventPacket(class EventPacket&) const;
    /*190*/ virtual void addExperience(int);
    /*191*/ virtual void addLevels(int);
    /*192*/ virtual void setContainerData(class IContainerManager&, int, int) = 0;
    /*193*/ virtual void slotChanged(class IContainerManager&, class Container&, int, class ItemStack const&, class ItemStack const&, bool) = 0;
    /*194*/ virtual void inventoryChanged(class Container&, int, class ItemStack const&, class ItemStack const&, bool);
    /*195*/ virtual void refreshContainer(class IContainerManager&) = 0;
    /*196*/ virtual void deleteContainerManager();
    /*197*/ virtual void setFieldOfViewModifier(float);
    /*198*/ virtual void __unk_vfn_53();
    /*199*/ virtual void __unk_vfn_54();
    /*200*/ virtual bool isTeacher() const = 0;
    /*201*/ virtual void onSuspension();
    /*202*/ virtual void onLinkedSlotsChanged();
    /*203*/ virtual void startCooldown(class Item const*, bool);
    /*204*/ virtual int getItemCooldownLeft(class HashedString const&) const;
    /*205*/ virtual int getItemCooldownLeft(unsigned __int64) const;
    /*206*/ virtual int getMaxItemCooldownLeft() const;
    /*207*/ virtual bool isItemInCooldown(class HashedString const&) const;
    /*208*/ virtual void sendInventoryTransaction(class InventoryTransaction const&) const = 0;
    /*209*/ virtual void sendComplexInventoryTransaction(std::unique_ptr<class ComplexInventoryTransaction>) const = 0;
    /*210*/ virtual void sendNetworkPacket(class Packet&) const;
    /*211*/ virtual class PlayerEventCoordinator& getPlayerEventCoordinator() = 0;
    /*212*/ virtual class MoveInputHandler* getMoveInputHandler() = 0;
    /*213*/ virtual enum InputMode getInputMode() const = 0;
    /*214*/ virtual enum ClientPlayMode getPlayMode() const = 0;
    /*215*/ virtual void reportMovementTelemetry(enum MovementEventType);
    /*216*/ virtual void __unk_vfn_55();
    /*217*/ virtual std::string getXuid() const;
    /*218*/ virtual struct PlayerMovementSettings const& getMovementSettings() const;
    /*219*/ virtual void onMovePlayerPacketNormal(class Vec3 const&, class Vec2 const&, float);
    /*220*/ virtual class std::shared_ptr<class ChunkViewSource> _createChunkSource(class ChunkSource&);
    /*
    inline bool canBePulledIntoVehicle() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?canBePulledIntoVehicle@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline enum StructureFeatureType getCurrentStructureFeature() const{
        enum StructureFeatureType (Player::*rv)() const;
        *((void**)&rv) = dlsym("?getCurrentStructureFeature@Player@@UEBA?AW4StructureFeatureType@@XZ");
        return (this->*rv)();
    }
    inline bool is2DPositionRelevant(class AutomaticID<class Dimension, int> a0, class BlockPos const& a1){
        bool (Player::*rv)(class AutomaticID<class Dimension, int>, class BlockPos const&);
        *((void**)&rv) = dlsym("?is2DPositionRelevant@Player@@UEAA_NV?$AutomaticID@VDimension@@H@@AEBVBlockPos@@@Z");
        return (this->*rv)(std::forward<class AutomaticID<class Dimension, int>>(a0), std::forward<class BlockPos const&>(a1));
    }
    inline bool isInTrialMode(){
        bool (Player::*rv)();
        *((void**)&rv) = dlsym("?isInTrialMode@Player@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool useNewAi() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?useNewAi@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isLoading() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isLoading@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isActorRelevant(class Actor const& a0){
        bool (Player::*rv)(class Actor const&);
        *((void**)&rv) = dlsym("?isActorRelevant@Player@@UEAA_NAEBVActor@@@Z");
        return (this->*rv)(std::forward<class Actor const&>(a0));
    }
    inline bool isSimulated() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isSimulated@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isHostingPlayer() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isHostingPlayer@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isLocalPlayer() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isLocalPlayer@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline unsigned int getUserId() const{
        unsigned int (Player::*rv)() const;
        *((void**)&rv) = dlsym("?getUserId@Player@@UEBAIXZ");
        return (this->*rv)();
    }
    inline void displayChatMessage(std::string const& a0, std::string const& a1){
        void (Player::*rv)(std::string const&, std::string const&);
        *((void**)&rv) = dlsym("?displayChatMessage@Player@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z");
        return (this->*rv)(std::forward<std::string const&>(a0), std::forward<std::string const&>(a1));
    }
    inline void openChalkboard(class ChalkboardBlockActor& a0, bool a1){
        void (Player::*rv)(class ChalkboardBlockActor&, bool);
        *((void**)&rv) = dlsym("?openChalkboard@Player@@UEAAXAEAVChalkboardBlockActor@@_N@Z");
        return (this->*rv)(std::forward<class ChalkboardBlockActor&>(a0), std::forward<bool>(a1));
    }
    inline void openBook(int a0, bool a1, int a2, class BlockActor* a3){
        void (Player::*rv)(int, bool, int, class BlockActor*);
        *((void**)&rv) = dlsym("?openBook@Player@@UEAAXH_NHPEAVBlockActor@@@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<bool>(a1), std::forward<int>(a2), std::forward<class BlockActor*>(a3));
    }
    inline void displayClientMessage(std::string const& a0){
        void (Player::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?displayClientMessage@Player@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline void openSign(class BlockPos const& a0){
        void (Player::*rv)(class BlockPos const&);
        *((void**)&rv) = dlsym("?openSign@Player@@UEAAXAEBVBlockPos@@@Z");
        return (this->*rv)(std::forward<class BlockPos const&>(a0));
    }
    inline void _serverInitItemStackIds(){
        void (Player::*rv)();
        *((void**)&rv) = dlsym("?_serverInitItemStackIds@Player@@MEAAXXZ");
        return (this->*rv)();
    }
    inline void playEmote(std::string const& a0){
        void (Player::*rv)(std::string const&);
        *((void**)&rv) = dlsym("?playEmote@Player@@UEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z");
        return (this->*rv)(std::forward<std::string const&>(a0));
    }
    inline void openPortfolio(){
        void (Player::*rv)();
        *((void**)&rv) = dlsym("?openPortfolio@Player@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void resetRot(){
        void (Player::*rv)();
        *((void**)&rv) = dlsym("?resetRot@Player@@UEAAXXZ");
        return (this->*rv)();
    }
    inline void stopLoading(){
        void (Player::*rv)();
        *((void**)&rv) = dlsym("?stopLoading@Player@@UEAAXXZ");
        return (this->*rv)();
    }
    inline bool isPlayer() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isPlayer@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isCreativeModeAllowed(){
        bool (Player::*rv)();
        *((void**)&rv) = dlsym("?isCreativeModeAllowed@Player@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool isPlayerInitialized() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isPlayerInitialized@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isAutoJumpEnabled() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isAutoJumpEnabled@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool canExistWhenDisallowMob() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?canExistWhenDisallowMob@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isShootable(){
        bool (Player::*rv)();
        *((void**)&rv) = dlsym("?isShootable@Player@@UEAA_NXZ");
        return (this->*rv)();
    }
    inline bool getAlwaysShowNameTag() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?getAlwaysShowNameTag@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline void openNpcInteractScreen(class std::shared_ptr<struct INpcDialogueData> a0){
        void (Player::*rv)(class std::shared_ptr<struct INpcDialogueData>);
        *((void**)&rv) = dlsym("?openNpcInteractScreen@Player@@UEAAXV?$shared_ptr@UINpcDialogueData@@@std@@@Z");
        return (this->*rv)(std::forward<class std::shared_ptr<struct INpcDialogueData>>(a0));
    }
    inline  ~Player(){
         (Player::*rv)();
        *((void**)&rv) = dlsym("??1Player@@UEAA@XZ");
        return (this->*rv)();
    }
    inline bool isCreative() const{
        bool (Player::*rv)() const;
        *((void**)&rv) = dlsym("?isCreative@Player@@UEBA_NXZ");
        return (this->*rv)();
    }
    */
    MCAPI Player(class Level&, class PacketSender&, enum GameType, class NetworkIdentifier const&, unsigned char, class mce::UUID, std::string const&, std::unique_ptr<class Certificate>, class EntityContext&, std::string const&, std::string const&);
    MCAPI void broadcastPlayerSpawnedMobEvent(enum ActorType, enum MobSpawnMethod);
    MCAPI bool canBeSeenOnMap() const;
    MCAPI bool canDestroy(class Block const&) const;
    MCAPI bool canUseAbility(enum AbilitiesIndex) const;
    MCAPI bool canUseOperatorBlocks() const;
    MCAPI void causeFoodExhaustion(float);
    MCAPI void clearRespawnPosition();
    MCAPI void eat(class ItemStack const&);
    MCAPI void eat(int, float);
    MCAPI bool equippedArmorItemCanBeMoved(class ItemStack const&) const;
    MCAPI void fireDimensionChangedEvent(class AutomaticID<class Dimension, int>);
    MCAPI bool forceAllowEating() const;
    MCAPI class Agent* getAgent() const;
    MCAPI struct ActorUniqueID getAgentID() const;
    MCAPI class Agent* getAgentIfAllowed(bool, struct ActorUniqueID) const;
    MCAPI class BlockPos const& getBedPosition() const;
    MCAPI __int64 getBlockedUsingDamagedShieldTimeStamp() const;
    MCAPI __int64 getBlockedUsingShieldTimeStamp() const;
    MCAPI __int64 getBlockingStartTimeStamp() const;
    MCAPI class Vec3 getCapePos(float);
    MCAPI class std::weak_ptr<class IContainerManager> getContainerManager();
    MCAPI class ItemStack const& getCurrentActiveShield() const;
    MCAPI float getDestroyProgress(class Block const&) const;
    MCAPI float getDestroySpeed(class Block const&) const;
    MCAPI int getDirection() const;
    MCAPI int getEnchantmentSeed() const;
    MCAPI class AutomaticID<class Dimension, int> getExpectedSpawnDimensionId() const;
    MCAPI class BlockPos const& getExpectedSpawnPosition() const;
    MCAPI std::string getInteractText() const;
    MCAPI class Container& getInventory();
    MCAPI class ItemStack const& getItemInUse() const;
    MCAPI std::string getItemInteractText(class Item const&) const;
    MCAPI class ItemStackNetManagerBase* getItemStackNetManager();
    MCAPI class ItemStackNetManagerBase const* getItemStackNetManager() const;
    MCAPI float getLuck();
    MCAPI int getMapIndex();
    MCAPI void getNewEnchantmentSeed();
    MCAPI class AABB getPickupArea() const;
    MCAPI enum BuildPlatform getPlatform() const;
    MCAPI std::string const& getPlatformOnlineId() const;
    MCAPI enum GameType getPlayerGameType() const;
    MCAPI int getPlayerIndex() const;
    MCAPI int getPlayerLevel() const;
    MCAPI enum PlayerPermissionLevel getPlayerPermissionLevel() const;
    MCAPI std::string const& getPlayerSessionId() const;
    MCAPI class ItemStack const& getPlayerUIItem(enum PlayerUISlot);
    MCAPI class BlockPos const& getRespawnAnchorPosition() const;
    MCAPI class ItemStack const& getSelectedItem() const;
    MCAPI int getSelectedItemSlot() const;
    MCAPI class SerializedSkin& getSkin();
    MCAPI class SerializedSkin const& getSkin() const;
    MCAPI float getSleepRotation() const;
    MCAPI class AutomaticID<class Dimension, int> getSpawnDimension() const;
    MCAPI class BlockPos const& getSpawnPosition() const;
    MCAPI class PlayerInventory& getSupplies();
    MCAPI class PlayerInventory const& getSupplies() const;
    MCAPI std::vector<struct ActorUniqueID> const& getTrackedBosses();
    MCAPI enum GameType getUnmappedPlayerGameType() const;
    MCAPI bool getUsedPotion();
    MCAPI int getXpNeededForNextLevel() const;
    MCAPI bool hasBedPosition() const;
    MCAPI bool hasOpenContainer() const;
    MCAPI bool hasOpenContainerOfContainerType(enum ContainerType) const;
    MCAPI bool hasOwnedChunkSource() const;
    MCAPI bool hasResource(class ItemDescriptor const&);
    MCAPI bool hasRespawnAnchorPosition() const;
    MCAPI bool hasRespawnPosition() const;
    MCAPI bool interact(class Actor&, class Vec3 const&);
    MCAPI bool isBouncing() const;
    MCAPI bool isForcedRespawn() const;
    MCAPI bool isHiddenFrom(class Mob&) const;
    MCAPI bool isHungry() const;
    MCAPI bool isHurt();
    MCAPI bool isInCreativeMode() const;
    MCAPI bool isInRaid() const;
    MCAPI bool isRespawningFromTheEnd() const;
    MCAPI bool isSleepingLongEnough() const;
    MCAPI bool isSpawned() const;
    MCAPI bool isSurvival() const;
    MCAPI bool isUsingItem() const;
    MCAPI void moveSpawnView(class Vec3 const&, class AutomaticID<class Dimension, int>);
    MCAPI void recheckSpawnPosition();
    MCAPI void releaseUsingItem();
    MCAPI void resetPlayerLevel();
    MCAPI void resetToDefaultGameMode();
    MCAPI void setAgent(class Agent*);
    MCAPI void setAllPlayersSleeping();
    MCAPI void setBedRespawnPosition(class BlockPos const&);
    MCAPI void setBlockRespawnUntilClientMessage(bool);
    MCAPI void setChunkRadius(unsigned int);
    MCAPI void setContainerManager(class std::shared_ptr<class IContainerManager>);
    MCAPI void setCursorSelectedItem(class ItemStack const&);
    MCAPI void setCursorSelectedItemGroup(class ItemGroup const&);
    MCAPI void setEnchantmentSeed(int);
    MCAPI void setHasSeenCredits(bool);
    MCAPI void setMapIndex(int);
    MCAPI void setPlatformOnlineId(std::string const&);
    MCAPI void setPlayerIndex(int);
    MCAPI void setPlayerUIItem(enum PlayerUISlot, class ItemStack const&);
    MCAPI void setRespawnPosition(class BlockPos const&, class AutomaticID<class Dimension, int>);
    MCAPI void setRespawnPositionCandidate();
    MCAPI void setRespawnReady(class Vec3 const&);
    MCAPI void setSelectedItem(class ItemStack const&);
    MCAPI class ItemStack const& setSelectedSlot(int);
    MCAPI void setSpawnBlockRespawnPosition(class BlockPos const&, class AutomaticID<class Dimension, int>);
    MCAPI void setUsedPotion(bool);
    MCAPI bool shouldShowCredits() const;
    MCAPI void spawnExperienceOrb(class Vec3 const&, int);
    MCAPI void startCooldown(class HashedString const&, int, bool);
    MCAPI void startGliding();
    MCAPI void startUsingItem(class ItemStack const&, int);
    MCAPI void stopGliding();
    MCAPI void stopUsingItem();
    MCAPI bool take(class Actor&, int, int);
    MCAPI void updateInventoryTransactions();
    MCAPI void updateSkin(class SerializedSkin const&, int);
    MCAPI void updateSpawnChunkView();
    MCAPI void updateTrackedBosses();
    MCAPI void useSelectedItem(enum ItemUseMethod, bool);
    MCAPI static float const DEFAULT_BB_HEIGHT;
    MCAPI static float const DEFAULT_BB_WIDTH;
    MCAPI static float const DEFAULT_FLY_SPEED;
    MCAPI static float const DEFAULT_PLAYER_HEIGHT_OFFSET;
    MCAPI static float const DEFAULT_WALK_SPEED;
    MCAPI static float const DISTANCE_TO_TRANSFORM_EVENT;
    MCAPI static float const DISTANCE_TO_TRAVELLED_EVENT;
    MCAPI static class Attribute const EXHAUSTION;
    MCAPI static class Attribute const EXPERIENCE;
    MCAPI static int const GLIDE_STOP_DELAY;
    MCAPI static class Attribute const HUNGER;
    MCAPI static int const ITEM_USE_INTERVAL_DURATION;
    MCAPI static class Attribute const LEVEL;
    MCAPI static int const MAX_ITEM_USE_DURATION;
    MCAPI static float const PLAYER_ALIVE_HEIGHT;
    MCAPI static float const PLAYER_ALIVE_WIDTH;
    MCAPI static float const PLAYER_DEAD_HEIGHT;
    MCAPI static float const PLAYER_DEAD_WIDTH;
    MCAPI static float const PLAYER_DOWN_SWIM_SPEED;
    MCAPI static float const PLAYER_GLIDING_CAMERA_OFFSET;
    MCAPI static float const PLAYER_SLEEPING_CAMERA_OFFSET;
    MCAPI static float const PLAYER_SLEEPING_HEIGHT;
    MCAPI static float const PLAYER_SLEEPING_WIDTH;
    MCAPI static float const PLAYER_SNEAK_OFFSET;
    MCAPI static float const PLAYER_SWIMMING_CAMERA_OFFSET;
    MCAPI static float const PLAYER_SWIM_BREACH_ANGLE;
    MCAPI static float const PLAYER_SWIM_ENTER_THRESHOLD;
    MCAPI static float const PLAYER_SWIM_FLY_MULTI;
    MCAPI static float const PLAYER_UP_SWIM_SPEED;
    MCAPI static class Attribute const SATURATION;
    MCAPI static unsigned int const SPAWN_CHUNK_LARGE_JUMP;
    MCAPI static unsigned int const SPAWN_CHUNK_RADIUS;
    MCAPI static void _aiStep(struct IPlayerMovementProxy&);
    MCAPI static void _jumpFromGround(struct IPlayerMovementProxy&);
    MCAPI static void _travel(struct IPlayerMovementProxy&, float, float, float);
    MCAPI static bool canJump(struct IPlayerMovementProxy&);
    MCAPI static bool checkAndFixSpawnPosition(class Vec3&, std::vector<class gsl::not_null<class BlockSource* >>, class AABB, bool, bool, bool, bool, bool, bool, short);
    MCAPI static bool checkNeedAutoJump(struct IPlayerMovementProxy*, float, float);
    MCAPI static void goDownInWater(struct IActorMovementProxy&);
    MCAPI static void handleJumpEffects(struct IPlayerMovementProxy&);
    MCAPI static class Player* tryGetFromComponent(class FlagComponent<struct PlayerComponentFlag> const&, class ActorOwnerComponent&, bool);
    MCAPI static class Player* tryGetFromEntity(class EntityContext&, bool);
    MCAPI static class Player* tryGetFromEntity(class StackRefResultT<struct EntityRefTraits>, bool);

protected:
    MCAPI bool _checkAndFixSpawnPosition(class Vec3&, std::vector<class gsl::not_null<class BlockSource* >>, bool, bool, bool, bool, bool) const;
    MCAPI void _chooseSpawnArea();
    MCAPI bool _chooseSpawnPositionWithinArea();
    MCAPI void _registerPlayerAttributes();
    MCAPI void _updateInteraction();
    MCAPI bool _validateSpawnPositionAvailability(class Vec3 const&, class BlockSource*, class Vec3 const*) const;
    MCAPI bool checkBed(class BlockSource*, class Vec3 const*);
    MCAPI bool checkSpawnBlock(class BlockSource const&) const;

private:
    MCAPI void _addLevels(int);
    MCAPI bool _blockUsingShield(class ActorDamageSource const&, float);
    MCAPI void _ensureSafeSpawnPosition(class Vec3&);
    MCAPI bool _findFallbackSpawnPosition(class Vec3&, std::vector<class gsl::not_null<class BlockSource* >>, unsigned int);
    MCAPI void _handleCarriedItemInteractText();
    MCAPI bool _isChunkSourceLoaded(class Vec3 const&, class BlockSource const&) const;
    MCAPI void _registerElytraLoopSound();
    MCAPI void _sendShieldUpdatePacket(class ShieldItem const&, class ItemStack const&, class ItemStack const&, enum ContainerID, int);

};