/**
 * @file  ResourcePackRepository.hpp
 * @note  This Header is auto generated by LiteLoaderBDS Toolchain.
 *
 */
#pragma once
#define AUTO_GENERATED
#include "../Global.h"
#include "Core.hpp"
#include "Bedrock.hpp"

#define BEFORE_EXTRA
// Include Headers or Declare Types Here

#undef BEFORE_EXTRA

/**
 * @brief MC class ResourcePackRepository.
 *
 */
class ResourcePackRepository {

#define AFTER_EXTRA
// Add Member There
public:
struct KnownPackContainer {
    KnownPackContainer() = delete;
    KnownPackContainer(KnownPackContainer const&) = delete;
    KnownPackContainer(KnownPackContainer const&&) = delete;
};
LIAPI void setCustomResourcePackPath(PackType, const std::string& path);

#undef AFTER_EXTRA
#ifndef DISABLE_CONSTRUCTOR_PREVENTION_RESOURCEPACKREPOSITORY
public:
    class ResourcePackRepository& operator=(class ResourcePackRepository const &) = delete;
    ResourcePackRepository(class ResourcePackRepository const &) = delete;
    ResourcePackRepository() = delete;
#endif

public:
    virtual ~ResourcePackRepository();
    virtual void getResourcePacksByPackId(std::vector<struct PackInstanceId> const &, std::vector<class PackInstance> &) const;
    virtual class ResourcePack * getResourcePackForPackId(struct PackIdVersion const &) const;
    virtual class ResourcePack * getResourcePackByUUID(class mce::UUID const &) const;
    virtual class ResourcePack * getResourcePackForPackIdOwned(struct PackIdVersion const &) const;
    virtual class ResourcePack * getResourcePackSatisfiesPackId(struct PackIdVersion const &, bool) const;
    virtual class ResourcePack * getResourcePackContainingModule(struct PackIdVersion const &) const;
    virtual class ResourcePack * getResourcePackInPath(class Core::Path const &) const;
    virtual bool isResourcePackLoaded(struct PackIdVersion const &, enum PackOrigin const &);
    virtual class PackSourceReport const * getPackLoadingReport() const;
    virtual class ResourcePack * getVanillaPack() const;
    virtual class ResourcePack * getChemistryPack() const;
    virtual class ResourcePack * getChemistryServerPack() const;
    virtual bool setServicePacks(std::vector<struct PackIdVersion>);
    virtual void addServicePacksToStack(class ResourcePackStack &) const;
    virtual void addCachedResourcePacks(class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string>>> const *);
    virtual void addWorldResourcePacks(class Core::Path const &);
    virtual void addPremiumWorldTemplateResourcePacks(class Core::Path const &, class ContentIdentity const &);
    virtual void removePacksLoadedFromCache();
    virtual void removePacksLoadedFromWorld();
    virtual class Core::PathBuffer<std::string> const getResourcePacksPath() const;
    virtual class Core::PathBuffer<std::string> const getBehaviorPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getSkinPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getDevelopmentResourcePacksPath() const;
    virtual class Core::PathBuffer<std::string> const getDevelopmentBehaviorPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getDevelopmentSkinPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getTreatmentPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getKnownPacksPath(enum KnownPackType) const;
    virtual class Core::PathBuffer<std::string> const getKnownValidPacksPath() const;
    virtual class Core::PathBuffer<std::string> const getKnownInvalidPacksPath() const;
    virtual void refreshPacks();
    virtual void requestReloadUserPacks();
    virtual void requestReloadDynamicPackagePacks();
    virtual class gsl::not_null<class Bedrock::NonOwnerPointer<class IContentKeyProvider const>> getKeyProvider() const;
    virtual class PackManifestFactory & getPackManifestFactory();
    virtual class PackSettingsFactory & getPackSettingsFactory() const;
    virtual class PackSourceFactory & getPackSourceFactory();
    virtual std::vector<class ResourcePack *> getPacksByResourceLocation(enum PackOrigin) const;
    virtual std::vector<class ResourcePack *> getPacksByType(enum PackType) const;
    virtual void addKnownPackFromImport(class PackManifest const &);
    virtual void addInvalidPack(class ResourceLocation const &, enum PackType);
    virtual std::vector<class ResourceLocation> const & getInvalidPacks(enum PackType) const;
    virtual std::vector<class ResourceLocation> getInvalidPacks(struct InvalidPacksFilterGroup const &) const;
    virtual void deletePack(class ResourceLocation const &);
    virtual void deletePackFiles(class ResourceLocation const &);
    virtual void postDeletePack(class ResourceLocation const &);
    virtual void untrackInvalidPack(class ResourceLocation const &);
    virtual void registerResourcePackRemovedCallback(void *, class std::function<void (class ResourcePack *)>);
    virtual void unregisterResourcePackRemovedCallback(void *);
    virtual bool isInitialized();
#ifdef ENABLE_VIRTUAL_FAKESYMBOL_RESOURCEPACKREPOSITORY
#endif
    MCAPI ResourcePackRepository(class IMinecraftEventing &, class PackManifestFactory &, class gsl::not_null<class Bedrock::NonOwnerPointer<class IContentAccessibilityProvider>> const &, class gsl::not_null<class Bedrock::NonOwnerPointer<class Core::FilePathManager>> const &, class PackSourceFactory &, bool);
MCAPI static class mce::UUID const CHEMISTRY_PACK_UUID;
MCAPI static class mce::UUID const CHEMISTRY_SERVER_PACK_UUID;

//private:
    MCAPI void _detectKnownPacksChange(struct ResourcePackRepository::KnownPackContainer &, struct ResourcePackRepository::KnownPackContainer const &, enum KnownPackType);
    MCAPI void _findVanillaPacks();
    MCAPI void _initialize();
    MCAPI void _initializeCachedPackSource();
    MCAPI void _initializePackSource();
    MCAPI void _initializeWorldPackSource();
    MCAPI void _loadLastKnownUserPacks(struct ResourcePackRepository::KnownPackContainer &, enum KnownPackType);
    MCAPI void _loadPacks(bool);
    MCAPI bool _packExists(class mce::UUID const &, class SemVersion const &, enum PackOrigin) const;
    MCAPI void _reloadUserPacks();
    MCAPI bool _removePack(class ResourceLocation const &, bool);
    MCAPI void _saveKnownUserPacks(struct ResourcePackRepository::KnownPackContainer &, enum KnownPackType);
    MCAPI void _triggerRemoveResourcePackCallback(class ResourcePack *);

private:

};