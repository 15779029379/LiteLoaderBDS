// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include <Global.h>
#define EXTRA_INCLUDE_PART
#include "Extra/ResourcePackRepositoryAPI.hpp"
#undef EXTRA_INCLUDE_PART
class ResourcePackRepository {
#include "Extra/ResourcePackRepositoryAPI.hpp"
public:
    virtual ~ResourcePackRepository();
    virtual void getResourcePacksByPackId(std::vector<struct PackInstanceId> const&, std::vector<class PackInstance>&);
    virtual class ResourcePack* getResourcePackForPackId(struct PackIdVersion const&);
    virtual class ResourcePack* getResourcePackByUUID(class mce::UUID const&);
    virtual class ResourcePack* getResourcePackForPackIdOwned(struct PackIdVersion const&);
    virtual class ResourcePack* getResourcePackSatisfiesPackId(struct PackIdVersion const&, bool);
    virtual class ResourcePack* getResourcePackContainingModule(struct PackIdVersion const&);
    virtual class ResourcePack* getResourcePackInPath(class Core::Path const&);
    virtual bool isResourcePackLoaded(struct PackIdVersion const&, int /*enum PackOrigin*/ const&);
    virtual void unk_vfn_9();
    virtual void unk_vfn_10();
    virtual void unk_vfn_11();
    virtual void unk_vfn_12();
    virtual bool setServicePacks(std::vector<struct PackIdVersion>);
    virtual void addServicePacksToStack(class ResourcePackStack&);
    virtual void addCachedResourcePacks(class std::unordered_map<class ContentIdentity, std::string, struct std::hash<class ContentIdentity>, struct std::equal_to<class ContentIdentity>, class std::allocator<struct std::pair<class ContentIdentity const, std::string>>> const*);
    virtual void addWorldResourcePacks(class Core::Path const&);
    virtual void addPremiumWorldTemplateResourcePacks(class Core::Path const&, class ContentIdentity const&);
    virtual void removePacksLoadedFromCache();
    virtual void removePacksLoadedFromWorld();
    virtual class Core::PathBuffer<std::string> const getResourcePacksPath();
    virtual class Core::PathBuffer<std::string> const getBehaviorPacksPath();
    virtual class Core::PathBuffer<std::string> const getSkinPacksPath();
    virtual class Core::PathBuffer<std::string> const getDevelopmentResourcePacksPath();
    virtual class Core::PathBuffer<std::string> const getDevelopmentBehaviorPacksPath();
    virtual class Core::PathBuffer<std::string> const getDevelopmentSkinPacksPath();
    virtual class Core::PathBuffer<std::string> const getTreatmentPacksPath();
    virtual class Core::PathBuffer<std::string> const getKnownPacksPath(int /*enum KnownPackType*/);
    virtual class Core::PathBuffer<std::string> const getKnownValidPacksPath();
    virtual class Core::PathBuffer<std::string> const getKnownInvalidPacksPath();
    virtual void refreshPacks();
    virtual void requestReloadUserPacks();
    virtual void requestReloadDynamicPackagePacks();
    virtual class IContentKeyProvider const& getKeyProvider();
    virtual void unk_vfn_34();
    virtual void unk_vfn_35();
    virtual class PackSourceFactory& getPackSourceFactory();
    virtual std::vector<class ResourcePack*> getPacksByResourceLocation(int /*enum PackOrigin*/);
    virtual std::vector<class ResourcePack*> getPacksByType(int /*enum PackType*/);
    virtual void addKnownPackFromImport(class PackManifest const&);
    virtual void addInvalidPack(class ResourceLocation const&, int /*enum PackType*/);
    virtual std::vector<class ResourceLocation> getInvalidPacks(struct InvalidPacksFilterGroup const&);
    virtual std::vector<class ResourceLocation> const& getInvalidPacks(int /*enum PackType*/);
    virtual void deletePack(class ResourceLocation const&);
    virtual void deletePackFiles(class ResourceLocation const&);
    virtual void postDeletePack(class ResourceLocation const&);
    virtual void untrackInvalidPack(class ResourceLocation const&);
    virtual void registerResourcePackRemovedCallback(void*, class std::function<void(class ResourcePack*)>);
    virtual void unregisterResourcePackRemovedCallback(void*);
    virtual bool isInitialized();

public:
    MCAPI static class mce::UUID const CHEMISTRY_PACK_UUID;
    MCAPI static class mce::UUID const CHEMISTRY_SERVER_PACK_UUID;

private:
    MCAPI bool _addResourcePackIfNotAlreadyAdded(class Pack&);
    MCAPI void _detectKnownPacksChange(struct ResourcePackRepository::KnownPackContainer&, struct ResourcePackRepository::KnownPackContainer const&, enum KnownPackType);
    MCAPI void _findVanillaPacks();
    MCAPI void _initialize();
    MCAPI void _initializeCachedPackSource();
    MCAPI void _initializePackSource();
    MCAPI void _initializeWorldPackSource();
    MCAPI void _loadLastKnownUserPacks(struct ResourcePackRepository::KnownPackContainer&, enum KnownPackType);
    MCAPI void _loadPacks(bool);
    MCAPI bool _packExists(class mce::UUID const&, class SemVersion const&, enum PackOrigin) const;
    MCAPI void _reloadDynamicPackagePacks();
    MCAPI void _reloadUserPacks();
    MCAPI bool _removePack(class ResourceLocation const&, bool);
    MCAPI void _saveKnownUserPacks(struct ResourcePackRepository::KnownPackContainer&, enum KnownPackType);
    MCAPI void _triggerRemoveResourcePackCallback(class ResourcePack*);
};