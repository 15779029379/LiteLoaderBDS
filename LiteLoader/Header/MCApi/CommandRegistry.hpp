// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#include <Global.h>
#include "CommandVersion.hpp"
#include "CommandParameterData.hpp"

enum class CommandFlagValue : char {
    None = 0,
    Usage = 1,
    Visibility2 = 2,
    Visibility4 = 4,
    Visibility6 = 6,
    Sync = 8,
    Execute = 16,
    Type = 32,
    Cheat = 64,
};

struct CommandFlag {
    CommandFlagValue value;

    constexpr bool operator==(CommandFlag const& rhs) const noexcept {
        return value == rhs.value;
    }
    constexpr bool operator!=(CommandFlag const& rhs) const noexcept {
        return value != rhs.value;
    }
    CommandFlag& operator|=(CommandFlag const& rhs) {
        value = (CommandFlagValue)((char)rhs.value | (char)value);
        return *this;
    }
};
constexpr inline CommandFlag CommandFlagNone = {CommandFlagValue::None};
constexpr inline CommandFlag CommandFlagUsage = {CommandFlagValue::Usage};
constexpr inline CommandFlag CommandFlagVisibility2 = {CommandFlagValue::Visibility2};
constexpr inline CommandFlag CommandFlagVisibility4 = {CommandFlagValue::Visibility4};
constexpr inline CommandFlag CommandFlagVisibility6 = {CommandFlagValue::Visibility6};
constexpr inline CommandFlag CommandFlagSync = {CommandFlagValue::Sync};
constexpr inline CommandFlag CommandFlagExecute = {CommandFlagValue::Execute};
constexpr inline CommandFlag CommandFlagType = {CommandFlagValue::Type};
constexpr inline CommandFlag CommandFlagCheat = {CommandFlagValue::Cheat};

class CommandRegistry {

public:
    struct ParseTable;
    struct ParseToken;
    class Symbol {
    public:
        unsigned val;
    };
    struct Overload {
        using FactoryFn = std::unique_ptr<Command> (*)(void);
        CommandVersion version;                   // 0
        FactoryFn factory;                        // 8
        std::vector<CommandParameterData> params; // 16
        char unk;                                 // 40
        inline Overload(CommandVersion version, FactoryFn factory, std::vector<CommandParameterData>&& args)
            : version(version)
            , factory(factory)
            , params(std::move(args))
            , unk(0xFF) {
        }
    };
    struct Signature {
        std::string name;                                 // 0
        std::string desc;                                 // 32
        std::vector<CommandRegistry::Overload> overloads; // 64
        CommandPermissionLevel perm;                      // 88
        CommandRegistry::Symbol main_symbol;              // 92
        CommandRegistry::Symbol alt_symbol;               // 96
        CommandFlag flag;                                 // 100
        int unk72;
        int unk76;
        int unk80;
        bool b84;

        inline Signature(
            std::string name, std::string desc, CommandPermissionLevel perm, CommandRegistry::Symbol symbol,
            CommandFlag flag)
            : name(name)
            , desc(desc)
            , perm(perm)
            , main_symbol(symbol)
            , flag(flag) {
        }
    };

    struct SoftEnum {
        std::string name;              // 0
        std::vector<std::string> list; // 32
    };
    MCAPI std::string getCommandName(std::string const&) const;
    MCAPI struct CommandSyntaxInformation getCommandOverloadSyntaxInformation(class CommandOrigin const&, std::string const&) const;
    MCAPI enum CommandStatus getCommandStatus(std::string const&) const;
    MCAPI bool isCommandOfType(std::string const&, enum CommandTypeFlag) const;
    MCAPI bool isValidCommand(std::string const&) const;
    MCAPI void registerAlias(std::string, std::string);
    MCAPI void registerCommand(std::string const&, char const*, enum CommandPermissionLevel, struct CommandFlag, struct CommandFlag);
    MCAPI bool requiresCheatsEnabled(std::string const&) const;
    MCAPI class AvailableCommandsPacket serializeAvailableCommands() const;
    MCAPI void setNetworkUpdateCallback(class std::function<void(class Packet const&)>);
    MCAPI void setScoreCallback(class std::function<int(bool&, std::string const&, class Actor const&)>);

    MCAPI static char const* COMMAND_NAME_ENUM_NAME;
    MCAPI static char const* FUNCTION_NAME_SOFTENUM_NAME;
    MCAPI static char const* TAG_VALUES_SOFTENUM_NAME;

private:
    MCAPI void _addEnumValueConstraintsInternal(std::vector<struct std::pair<unsigned __int64, unsigned int>> const&, enum SemanticConstraint);
    MCAPI class CommandRegistry::Symbol _addFunctionSoftEnum();
    MCAPI class CommandRegistry::Symbol _getConstrainedParamEnumSymbol(class CommandRegistry::Symbol) const;
    MCAPI bool _isCommandElementValid(std::string const&) const;
    MCAPI bool _matchesEnumConstraintsSet(class CommandRegistry::Symbol const&, class CommandOrigin const&, class CommandRegistry::Symbol const&, enum SemanticConstraint) const;
    MCAPI void addEnumValuesToExisting(unsigned int, std::vector<struct std::pair<unsigned __int64, unsigned __int64>> const&);
    MCAPI class CommandRegistry::Symbol addPostfix(std::string const&);
    MCAPI void addSemanticConstraint(enum SemanticConstraint);
    MCAPI class CommandRegistry::Symbol addSoftTerminal(std::string const&);
    MCAPI void buildFirstSet(struct CommandRegistry::ParseTable&, class CommandRegistry::Symbol, unsigned int) const;
    MCAPI void buildFollowSet(struct CommandRegistry::ParseTable&, class CommandRegistry::Symbol, unsigned int, class std::set<class CommandRegistry::Symbol, struct std::less<class CommandRegistry::Symbol>, class std::allocator<class CommandRegistry::Symbol>>&) const;
    MCAPI void buildOverload(struct CommandRegistry::Overload&);
    MCAPI void buildParseTable(unsigned int) const;
    MCAPI class CommandRegistry::Symbol buildRules(struct CommandRegistry::Signature&, std::vector<struct CommandRegistry::Overload*> const&, unsigned __int64);
    MCAPI bool checkOriginCommandFlags(class CommandOrigin const&, struct CommandFlag, enum CommandPermissionLevel) const;
    MCAPI std::string describe(struct CommandRegistry::Signature const&, std::string const&, struct CommandRegistry::Overload const&, unsigned int, unsigned int*, unsigned int*) const;
    MCAPI std::string describe(class CommandParameterData const&) const;
    MCAPI std::string describe(class CommandRegistry::Symbol) const;
    MCAPI struct CommandRegistry::Signature* findCommand(std::string const&);
    MCAPI struct CommandRegistry::Signature const* findCommand(std::string const&) const;
    MCAPI class CommandRegistry::Symbol findEnumValue(std::string const&) const;
    MCAPI class CommandRegistry::Symbol findIdentifierInfo(std::string const&) const;
    MCAPI class CommandRegistry::Symbol findPostfix(std::string const&) const;
    MCAPI std::vector<class CommandRegistry::Symbol> first(struct CommandRegistry::ParseTable&, std::vector<class CommandRegistry::Symbol> const&) const;
    MCAPI void forEachNonTerminal(class std::function<void(class CommandRegistry::Symbol)>) const;
    MCAPI unsigned __int64 getEnumData(struct CommandRegistry::ParseToken const&) const;
  //MCAPI struct InvertableFilter<std::string> getInvertableFilter(struct CommandRegistry::ParseToken const&) const;
    MCAPI bool isValid(class CommandRegistry::Symbol) const;
    MCAPI bool originCanRun(class CommandOrigin const&, struct CommandRegistry::Overload const&) const;
    MCAPI bool originCanRun(class CommandOrigin const&, struct CommandRegistry::Signature const&) const;
    MCAPI void registerOverloadInternal(struct CommandRegistry::Signature&, struct CommandRegistry::Overload&);
    MCAPI void setupOverloadRules(struct CommandRegistry::Signature&, struct CommandRegistry::Overload&);
    MCAPI std::string symbolToString(class CommandRegistry::Symbol) const;

    MCAPI static std::string _removeStringQuotes(std::string const&);
    MCAPI static struct CommandRegistry::ParseToken* collapse(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol);
    MCAPI static struct CommandRegistry::ParseToken* collapseOn(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol, class CommandRegistry::Symbol);
    MCAPI static struct CommandRegistry::ParseToken* expand(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol);
    MCAPI static struct CommandRegistry::ParseToken* expandExcept(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol, class CommandRegistry::Symbol);
    MCAPI static struct CommandRegistry::ParseToken* fold(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol, class CommandRegistry::Symbol);
    MCAPI static struct CommandRegistry::ParseToken* kill(struct CommandRegistry::ParseToken&, class CommandRegistry::Symbol);
};